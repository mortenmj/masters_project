% Chapter Template
\providecommand{\rootfolder}{../..} % Relative path to main.tex
\documentclass[\rootfolder/main.tex]{subfiles}
\begin{document}
\chapter{Modelica} % Main chapter title

\label{Chapter02} % Change X to a consecutive number; for referencing this chapter elsewhere, use \cref{ChapterX}

\section{Language features}

Modelica is an object-oriented programming language for specifying models of large, complex, and heterogenous physical systems \cite{clauss2002}.
The language can be used to model systems in fields like mechanical engineering, biology, robotics, and more.
It supports the creation of mixed-domain models, for example combining electric power, hydraulic systems, and thermal systems.
Many types of flows are already implemented in Modelica, such as torque, voltage or heat.
It is also possible for model developers to create their own flow variables.
This could, for example, be chemicals necessary for modelling a specific chemical processes.

In Modelica, models are mathematically described by differential or algebraic equations, and they can be discrete or continuous.
It is also possible to define algorithms like those in imperative languages.
Models are made by composition of components, which in turn are implemented by equations or by programming them imperatively.
The models are created by connecting graphical representations of the components in a composition diagram.
Modelica is object-oriented, and each component in a composition is implemented as a class.

In order to illustrate the advantages and disadvantages between Modelica and the other simulation packages we review later, we will use the following example repeatedly \footnotemark.
Consider a simple drive train, consisting of two rotational inertial loads, with a spring-damper between the two, and between the second load and a rigid frame as shown in \cref{fig:inertial}.

\footnotetext{The example is inspired by \emph{Modelica By Example}, by Michael M. Tiller \cite{openmodelica.org:tiller:2014}.}

\begin{figure}[ht]
    \iimage{Figures/InertialBasic}
    \caption{Graphical implementation of inertial system.\label{fig:inertial}}
\end{figure}

\subsection{Equations and algorithms}

First, let us look at what it means when we say that Modelica is equation-based.
In an imperative language, statements are evaluated sequentially and assigning a value to a variable would overwrite whatever value it may have held previously.
This is not the case in Modelica, and it is possible to express statements which are simultaneously valid.
In a strictly imperative programming language, the second statement would override the first in the following example:

\inputminted[fontsize=\footnotesize]{Modelica}{\rootfolder/Chapters/Chapter2/Listings/simultaneous.txt}

To look at how this is used to define a physical system, we will implement the equations for the model from \cref{fig:inertial} in text form.
The equations for the system are derived by Newton's second law for rotation.
If we let $J$ be the moment of inertia, $\varphi$ be the angular displacement, $\omega$ be the angular velocity and, $\tau$ be the torque, the law states that

\loadeq{\rootfolder/Equations.tex}{005} % Newton's second in a rotating system

Combining these equations gives the following system of differential equations:

\loadeq{\rootfolder/Equations.tex}{006} % Differential equations for the inertial system

As stated, it is possible to define complex equations simply by stating the necessary expressions, just like one would write them on paper.
We will use this in order to implement the system shown above.
\Cref{lst:inertial-code} shows a direct implementation of \cref{eq:inertial}.

\begin{listing}[ht]
    \inputminted[fontsize=\footnotesize]{Modelica}{\rootfolder/Models/MasterProject/Models/InertialCode.mo}
    \caption{Code implementation of the inertial system in \cref{eq:inertial}.\label{lst:inertial-code}}
\end{listing}

As stated, it is also possible to implement programs like this in imperative languages.
This may be done in algorithm blocks within models, which may coexist with the equation blocks seen above, or they may be implemented as separate functions and then called from a model.
It is also possible to call an external function in this way, written in e.g. the C language.
This allows for complex model behavior.
One example, which is highly relevant to the field of cybernetics, would be to model the behavior of a system of elevators in Modelica, and implement a control system in a different language.
This would allow efficient, automated, testing of the control system, by replacing the physical elevator system with a computer model.

\subsection{Object-oriented features}

As Modelica is object-oriented we could, if we wanted to, separate a model into smaller component parts, and connect these components to one another to form a complete model.
In the previous example, it would make sense to implement the inertial load and the spring-damper as separate classes, and connect instances of them to form the model.
When creating a model by connecting graphical components in Modelica, this instantiation and connecting of objects is done behind the scenes.
If we look at the code of the first model, shown in \cref{fig:inertial}, we see that it does exactly what we propose above.
The code in \cref{lst:inertial-basic} is the code generated when the model in \cref{fig:inertial} was created\footnotemark:

\footnotetext{Annotations which describe the placement of components has been removed}

\begin{listing}[ht]
    \inputminted[fontsize=\footnotesize]{Modelica}{\rootfolder/Models/MasterProject/Models/InertialBasic2.mo}
    \caption{Text view of the model in \cref{fig:inertial}.\label{lst:inertial-basic}}
\end{listing}

Most of the key features in object-oriented languages are implemented in Modelica.
Among these are encapsulation, inheritance, information hiding and polymorphism.
We will extend our model in order to have a look at some of these features.
In \cref{fig:inertial-expanded} we have added a torque input to the left of the first left, and a sensor for measuring the rotation speed of the second shaft.
Also, a PID controller has been added, which drives the shaft speed to follow a reference signal.

\begin{figure}[ht]
    \iimage{Figures/InertialExpanded}
    \caption{Expanded system.\label{fig:inertial-expanded}}
\end{figure}

As we can see, the model roughly consists of five subsystems: a reference signal, an actuator, the inertial system itself, a speed sensor, and a controller.
Just like these subsystems are made up of smaller components, we can create a component representing each subsystem.
This allows us to hide implementation details, and gives a clearer view of how the system is structured.
This generalised model is shown in \cref{fig:inertial-architecture}.

\begin{figure}[ht]
    \iimage{Figures/InertialArchitecture}
    \caption{System with replaceable subsystems.\label{fig:inertial-architecture}}
\end{figure}

Here, each block is a separate model, which can be developed independently of the main model.
In \cref{fig:inertial-architecture-blowup} we show how the new component, named "plant", now contains the same shaft and spring-damper assembly as in the previous models.
Furthermore, the component now inherits from a library interface named "PartialTwoFlangesAndSupport"
This interface provides input and output flanges, as well as the option between using a support flange or allowing the component to be implicitly supported.
This process can be repeated indefinitely, and the model shown in the figure might easily be a component in another, larger model.
Structuring models in this way makes them easier to understand, and allows for model reuse.

\begin{figure}[ht]
    \scriptsize
    \iimage{Figures/InertialArchitectureBlowup2}
    \caption{Expanded view of the actuator (left) and plant subsystem (right).\label{fig:inertial-architecture-blowup}}
\end{figure}

We can take this process one step further, and replace the subsystems with virtual subsystems, or interfaces, to get even greater reusability from our models.
A component in a model declared as "replaceable" can be replaced with any plug-compatible component, i.e. any component with the same inputs and outputs.
We may choose to either use a partial model, which is the Modelica term for an interface, or some default model that can be replaced when desired.
Then, when we instantiate a model, we supply a component for each subsystem that is to be replaced.

\begin{listing}[ht]
    \inputminted[fontsize=\footnotesize]{Modelica}{\rootfolder/Models/MasterProject/Models/InertialImplementation.mo}
    \caption{Instantiation of the inertial system.\label{lst:inertial-instantiation}}
\end{listing}

In this case, the model has an ideal speed sensor. 
However, when modelling a real system, it would be more useful to replace this with a model that mimics the operation of a real sensor.
There are many possible sensors for measuring the rotational speed of a shaft, and it would be useful if these could be implemented as components and quickly swapped into the model.
In this case, the plant will be the only constant part of the model, while the controller, the actuator, the sensor and the signal source will be made replaceable.
What used to be a model is now a model architecture, and needs to be instantiated with components.
The code in \cref{lst:inertial-instantiation} shows how this is done.
Scalar inputs and outputs are used in this example.
However, the interfaces may trivially be changed to accept multiple inputs and outputs, which would make our architecture even more general.

Where necessary, it is also possible to create adapter models which wrap a subsystem and convert the output to whatever format the rest of the model requires.
For example, while our sensor measures the rotational speed of the drive shaft, in some other application we might prefer to know the drive shaft position.
This is very useful when different parts of models are created independently.

As the model instantiation in \cref{lst:inertial-instantiation} is in a pure text format, any number of programming languages could be used to change the definition of the model.
Using e.g. the Python bindings for OpenModelica or Dymola, model variations can be generated and simulated without resorting to manually using a graphical interface.

\subsection{Mixed-domain models}

Modelica allows for easy creation of mixed-domain models \cite{clauss2002}.
\Cref{fig:inertial-architecture-blowup} shows one such example, where the actuator from \cref{fig:inertial-architecture} is implemented as a simple model of an induction motor.
Additionally, the resistor in the model has a heat port which allows the motor to be thermally connected to the rest of the system.
While this simple example is limited to electric flow, torque and, optionally heat flow, it is possible to model any number of physical quantities in Modelica.
A similar component to that shown in \cref{fig:inertial-architecture-blowup} could, as an example, easily be connected to a valve that controls liquid flow, all in one model.
The Modelica library contains more detailed examples showing how to model heat flow\footnotemark and liquid flow\footnotemark.

\footnotetext{\url{http://doc.modelica.org/om/Modelica.Thermal.HeatTransfer.Examples.html}}
\footnotetext{\url{http://doc.modelica.org/om/Modelica.Fluid.Examples.html}}

This can also be extended to model phenomena outside of the engineering disciplines.
As an example, the PhysioLibrary project publishes a Modelica library for modelling all aspects of human physiology.

\subsection{Causal and acausal}

\begin{figure}[ht]
    \centering
    \subcaptionbox{Component implementation.\label{fig:rlc-comp}}
        {
            \iimage{Figures/RLCcomponents}
        }\par\bigskip
        \subcaptionbox{Block implementation.\label{fig:rlc-block}}
        {
            \iimage{Figures/RLCblocks}
        }
    \caption{RLC circuit comparing component and block implementations.\label{fig:rlc}}
\end{figure}

In the model in \cref{fig:inertial-architecture}, most subsystems are components while the reference sinusous is a block.
We will quickly review the differences between the two, and provide an example of their relative strengths.
A block in Modelica is a causal model.
In short, a causal model relates inputs to outputs. In Modelica, there are many such blocks, which implement operations such as integration, gain, sinusoids etc.
Conversely, acausal modelling creates the model from components that implement the behaviors of their real-world counterparts, such as the spring-damper we used previously.
While it is more difficult to implement acausal simulation software \cite{tiller2001}, there are many benefits to the user.
An example is provided in \cite{harman2006}.
Here, the modelling of hydraulic components for automotive systems is discussed.

\begin{displayquote}[\cite{harman2006}][\dots]
    For some components a pressure drop across the component is the only data available.
    With some modelling tools it would be necessary to reverse-engineer an orifice size and flow coefficient to achieve this pressure drop.
    However the ActuationHydraulics library exploits the acausal capabilities of Modelica and allows the choice of a flow-model where pressure drop is specified as a function of flow.
\end{displayquote}

Creating the model from acausal components is also often quicker and easier for the user.
To illustrate this, we implement a simple parallel RLC circuit.
In \cref{fig:rlc-comp} we create an acausal model, by dragging and dropping components that implement the behavior of the circuit elements.
Compare to \cref{fig:rlc-block} which implements the same circuit using block components.
As before, these circuit components can easily be replaced by plug-compatible versions, making it trivial to e.g. replace the resistors with components that also model heat buildup.

\section{Simulation}

Here we will look at how software implementation of Modelica typically handle model simulation.
Because Modelica supports acausal modelling, the process of running the simulation is significantly more involved than otherwise.

\subsection{System transformation}

Before a model can be used, it must first be translated into a form which can be simulated in an efficient manner.
Typically, Modelica models are translated into a flat system of differential and algebraic equations (DAEs) \cite{openmodelica.org:lundvall:sims:2005}.
The translation process expands base classes, redeclarations and so on, to form the flat set of equations.
This is done to create a system of equations that is free of the original object hierarchy of the model.
Modelica allows for the creation of very large models, where real-life use cases can scale to a size of more than a hundred thousand variables
For this reason, systems must be optimized before simulation takes place.

Modelica models are generally hybrid systems, consisting of both differential-algebraic and discrete equations.
While there are DAE solvers capable of handling the continuous parts of hybrid systems, there are no general purpose solvers capable of handling these systems.
In order to overcome this problem, Modelica translators first translate the systems using symbolic transformation algorithms, into a form that can be integrated.
Before simulation the systems are processed to reduce the number of unknowns, using techniques such as BLT-partitioning and tearing \cite{clauss2002} to translate the system.

As the systems created by Modelica are composed from acausal components, the complete system will generally have fewer states than the total sum of the states of the components.
This is referred to as the DAE system having a high index.
Solving such a systems requires that equations are differentiated as we will see in the following example, which is adapted from \cite{clauss2002}.

\begin{figure}[ht]
	\begin{minipage}[c]{.75\columnwidth}
	    \iimage{Figures/InertialRigid}
	\end{minipage}%
	\begin{minipage}[c]{.25\columnwidth}
	    \loadeq{\rootfolder/Equations.tex}{007}
	\end{minipage}
    \caption{Rigid driveshaft model with corresponding equations.}
\end{figure}

Here, the system has more equations than strictly needed;
J1 and J2 are rigidly connected and as such they must have the same angles and velocities.
The system must be transformed to the form $\frac{d\vec{x}}{dt} = f\left(\vec{x}, t\right)$.
However, the relation $\varphi_{1} = \varphi_{2}$ must be differentiated twice to solve for $\tau_{2}$.
This is a problem, as numerical integration algorithms can only handle systems that require differentiation no more than once.

To solve this problem, the standard technique is as follows \cite{clauss2002}:
\begin{itemize}
    \item Determine how many times each equation must be differentiated, using the Pantelides algorithm
    \item Differentiate analytically
    \item Select state variables (at compiletime if possible, or at runtime)
\end{itemize}

The final representation of the system consists of both the continuous-time and discrete-time behavior of the system \cite{openmodelica.org:lundvall:sims:2005}:

\loadeq{\rootfolder/Equations.tex}{008} % Equation system generated by Modelica

The continuous-time behavior, between events, is given by \cref{eq:dae-system}.
The equations warrant some explanation.

\begin{itemize}[noitemsep]
    \item $\vec{x}(t)$ are the dynamic variables of the system
    \item $\vec{u}(t)$ are the system inputs
    \item $\vec{y}(t)$ are other system variables, including outputs
    \item $\vec{q}(t_{e})$ are discrete-time variables, at event instants $t_{e}$
    \item $\vec{q_{pre}}(t_{e})$ are the discrete-time variables from the previous event instant
    \item $\vec{c}(t_{e})$ are boolean conditional expressions, given by when- and if-conditions
    \item $\vec{p}$ is a vector of system parameters and constants.
    \item $\vec{rel}(\vec{v}(t_{e}))$ is a boolean vector of relevant relation expressions in the model; $\vec{v}(t_{e}$ is a vector of all variables in the vectors above.
\end{itemize}

The equations are more thoroughly explained in \cite{openmodelica.org:lundvall:sims:2005}.

\subsection{DAE solution algorithm}

\begin{figure}[H]
    \centering
    \includegraphics{Figures/flowchart}
    \caption{Solution algorithm flowchart.\label{fig:dae-flowchart}}
\end{figure}

As stated, the system description in \cref{eq:dae-system} is only valid between events, and the simulation is therefore performed piecewise.
At event instants, points in time where the model is non-continuous, the hybrid DAE system must be reinitialized before simulation continues.
A flowchart describing the procedure is shown in \cite{openmodelica.org:lundvall:sims:2005}, and reproduced in \cref{fig:dae-flowchart}.
The following steps are performed when simulating the system:

\begin{enumerate}
    \item Before the continous part of the DAE, shown in \cref{eq:dae-continuous}, can be simulated, the system must determine the set of initial conditions for the problem.
	This generally requires the solution of a system of equations which determine the system constraints.

    \item After determining initial conditions, the system checks all event conditions, such as when- and if-statements, to see if any events need to be fired.

    \item After the event conditions are processed, events are fired if necessary.
	If any events were fired, the initial conditions must be recalculated and the simulation restarted with new initial conditions.
	Following this, event conditions are reevaluated as new conditions may have changed as a result of changes caused by the event.

    \item Once the system is stable, that is when no more events need to fire, the simulation proceeds.
	In this step, the vectors $\vec{q}$, $\vec{q_{pre}}$, and $\vec{c}$ are kept constant, so that \cref{eq:dae-continuous} is a set of continuous functions of continuous variables.

	Once any of the conditions in $\vec{c}$ that are relevant, determined by $\vec{rel}(\vec{v}(t_{e}))$, the continuous simulation is halted and event conditions are evaluated.
	The system repeats the process of firing events, and reevaluating conditions, until the new set of continuous equations can be simulated.
\end{enumerate}

The boolean conditions are divided into two groups, continuous or discrete.
Discrete conditions can only change value at discrete time instances $t_{e}$, and offer no problems.
These are simply evaluated at every discrete time step.
Continuous conditions are converted into a continuous function which crosses zero at the time the condition changes from true to false.
The DAE solution algorithm can efficiently monitor the function to detect when this happens \cite{openmodelica.org:lundvall:sims:2005}.

\section{Functional Mock-up Interface}

\subsection{Overview}

\begin{displayquote}[\cite{harman2006}][\dots]
    [The] \emph{Functional Mock-up Interface} (FMI) is a tool independent standard to support both model exchange and co-simulation of dynamic models using a combination of xml-files and compiled C-code
\end{displayquote}

Today, there are a variety of simulation tools available, which support a large variety of modelling languages.
Some tools are general purpose, such as Modelica, while others can be quite specialized.
In general, these tools do not interoperate.
In today's industry highly complex, interdisciplinary models are frequently required, which often requires the use of specialized modelling tools or languages.
Manufacturers have a need to connect models developed by their suppliers, but models have typically been locked into the software they are made in.  This has prompted the development of an open standard for model exchange.
FMI was developed for the exchange of models in the automotive industry, and aims to improve this issue.
Today, FMI is used by many companies both within and without the industry \cite{fmispecification}.
The standard is currently developed by the Modelica Association.

Using FMI, models can be developed and shared between simulation tools, allowing for greater reuse and early validation of designs \cite{Blochwitz2011}.
Additionally, simplified model exchange makes possible early validation of designs, as the designs from several suppliers can be tested together.

Modelica is one of the simulation packages that can export models to the FMI format, and all Modelica variable attributes can be exchanged.
The FMI models can be connected hierarchically, just like Modelica models, and they can optionally include their own solver, when using the FMI co-simulation standard.

The FMI standard defines an XML schema which is used to describe the model components, a C API for implementing the model.
This is used to define \emph{Functional Mock-up Unit}, or FMUs, which are typically exported from modelling tools which support the FMI standard.
An FMU consists of the following elements:

\begin{itemize}
    \item The model description file, an XML-file with all exposed variables in the model.
    \item The model implementation, A collection of C source files or the compiled binaries.
        This may be an implementation of the model equations, or an interface which communicates with an external tool.
    \item Additional data such as an icon bitmap, parameter tables, object libraries and so on.
\end{itemize}

Roughly, there are two ways FMI may be employed, as shown in \cref{fig:fmi}.
Using \emph{model exchange}, the model is simply imported into a modelling tool which supports FMI and simulation is handled by the tool.
Using \emph{co-simulation}, each FMU handles its own simulation.

\begin{figure}[ht]
    \centering
    \subcaptionbox{Model exchange.\label{fig:fmi-exchange}}[0.4\columnwidth][l]
        {
            \includegraphics[width=0.37\columnwidth]{Figures/fmi-exchange}
        }
        \subcaptionbox{Co-simulation.\label{fig:fmi-cosim}}[0.4\columnwidth][r]
        {
            \includegraphics[width=0.37\columnwidth]{Figures/fmi-cosim}
        }
    \caption{The two interface standards for FMI.\label{fig:fmi}}
\end{figure}

\subsection{Model exchange}

\subsection{Co-simulation}

Often, complex models that combine multiple physical domains are difficult, or even impossible, to create with one software tool.
Using the FMI standard, this can be solved by modelling separate parts of the model in specialized software, and including the numerical solver with the model.
In the FMI standard, this is called co-simulation.

An illustrative example of the power of co-simulation is given in \cite{Schofield}, which implements an anti-lock braking system.
This is an example of a system that spans multiple physical domains.
As stated by \cite{Schofield}, Modelica is appropriate for models involving multiple physical domains.
However, while it is far more computationally intensive, in some cases the higher quality results that can be obtained by using finite element models justify the effort.
This is relevant in cases where physically-derived models are unavailable, or where high resolution is required.
In this case, while there are models which approximate tyre dynamics, such as the magic formula tyre model \cite{Pacejka2012}, these models do not capture as much detail as a finite element model.
Using co-simulation, it is possible to implement these parts as a finite element model, and other parts in e.g. Modelica, as shown by \cite{Schofield}.

Broadly speaking, the main components of an ABS system model is the tyre, the brake system, the road surface and the ABS controller.
Here, Abaqus is used to implement high-fidelity models of the tyre, road and brake caliper/disc assembly.
These components exhibit behaviors which cannot easily be captured in a model based tool such as those based on Modelica.

Many tyre manufacturers use detailed finite element models of their tyres to study the tyres response to different loading conditions;
As a result, tyre models and road surface models are available.
In \cite{Schofield}, a finite element model of the tyre, including the thread, plies and wire support structure is used in order to accurately predict the stresses and deformations of the tyre at different speeds.

The ABS controller, as well as the hydraulics of the braking system, are well suited for modelling in Modelica and are using the HyLib hydraulics library.
The ABS controller receives sensor data from the tyre, such as forward velocity of the vehicle, the angular velocity of the tyre and the effective rolling radius of the tyre as it deforms.
This information is transmitted from the finite element model, in Abaqus, to the control algorithm, in Dymola.
The ABS controller regulates an hydraulic solenoid and computes the brake caliper clamp force, which is transmitted back to Abaqus.
Abaqus then solves for the resulting dynamics in the brake caliper and tyre.

The paper compares this implementation to one created entirely with Modelica.
While the paper shows that it is possible to implement a simple model of the tyres and brakes in Modelica, it obtains more realistic results by using a high-fidelity finite element model.

\section{Scripting interface}

Models created with Modelica can be compiled to an FMU using PyModelica, and simulated using PyFMI, both part of the JModelica project.
While the complexity in setting up this toolchain is significant, the available interface once initial setup is done is attractive.

\begin{figure}[ht]
	\begin{minipage}[c]{.5\columnwidth}
	    \iimage{Figures/InertialSimulation}
	\end{minipage}%
	\begin{minipage}[c]{.5\columnwidth}
        \inputminted[fontsize=\footnotesize]{Python}{\rootfolder/Chapters/Chapter2/Listings/simulate.py}
	\end{minipage}
    \caption{Python script showing how to run Modelica simulation, with output}
\end{figure}


\end{document}
