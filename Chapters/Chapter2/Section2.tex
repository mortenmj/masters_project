%---------------------------------------------------------------------------------------
%   Modelica
%----------------------------------------------------------------------------------------

\providecommand{\rootfolder}{../..} % Relative path to main.tex
\documentclass[\rootfolder/main.tex]{subfiles}
\begin{document}
\section{Simulation}

Here we will look at how software implementation of Modelica typically handle model simulation.
Because Modelica supports acausal modelling, the process of running the simulation is significantly more involved than otherwise.

\subsection{System transformation}

Before a model can be used, it must first be translated into a form which can be simulated in an efficient manner.
Typically, Modelica models are translated into a flat system of differential and algebraic equations (DAEs) \cite{openmodelica.org:lundvall:sims:2005}.
The translation process expands base classes, redeclarations and so on, to form the flat set of equations.
This is done to create a system of equations that is free of the original object hierarchy of the model.
Modelica allows for the creation of very large models, where real-life use cases can scale to a size of more than a hundred thousand variables
For this reason, systems must be optimized before simulation takes place.

Modelica models are generally hybrid systems, consisting of both differential-algebraic and discrete equations.
While there are DAE solvers capable of handling the continuous parts of hybrid systems, there are no general purpose solvers capable of handling these systems.
In order to overcome this problem, Modelica translators first translate the systems using symbolic transformation algorithms, into a form that can be integrated.
Before simulation the systems are processed to reduce the number of unknowns, using techniques such as BLT-partitioning and tearing \cite{clauss2002} to translate the system.

As the systems created by Modelica are composed from acausal components, the complete system will generally have fewer states than the total sum of the states of the components.
This is referred to as the DAE system having a high index.
Solving such a systems requires that equations are differentiated as we will see in the following example, which is adapted from \cite{clauss2002}.

\begin{figure}[ht]
	\begin{minipage}[c]{.75\columnwidth}
	    \iimage{Figures/InertialRigid}
	\end{minipage}%
	\begin{minipage}[c]{.25\columnwidth}
	    \loadeq{\rootfolder/Equations.tex}{007}
	\end{minipage}
    \caption{Rigid driveshaft model with corresponding equations.}
\end{figure}

Here, the system has more equations than strictly needed;
J1 and J2 are rigidly connected and as such they must have the same angles and velocities.
The system must be transformed to the form $\frac{d\vec{x}}{dt} = f\left(\vec{x}, t\right)$.
However, the relation $\varphi_{1} = \varphi_{2}$ must be differentiated twice to solve for $\tau_{2}$.
This is a problem, as numerical integration algorithms can only handle systems that require differentiation no more than once.

To solve this problem, the standard technique is as follows \cite{clauss2002}:
\begin{itemize}
    \item Determine how many times each equation must be differentiated, using the Pantelides algorithm
    \item Differentiate analytically
    \item Select state variables (at compiletime if possible, or at runtime)
\end{itemize}

The final representation of the system consists of both the continuous-time and discrete-time behavior of the system \cite{openmodelica.org:lundvall:sims:2005}:

\loadeq{\rootfolder/Equations.tex}{008} % Equation system generated by Modelica

The continuous-time behavior, between events, is given by \cref{eq:dae-system}.
The equations warrant some explanation.

\begin{itemize}[noitemsep]
    \item $\vec{x}(t)$ are the dynamic variables of the system
    \item $\vec{u}(t)$ are the system inputs
    \item $\vec{y}(t)$ are other system variables, including outputs
    \item $\vec{q}(t_{e})$ are discrete-time variables, at event instants $t_{e}$
    \item $\vec{q_{pre}}(t_{e})$ are the discrete-time variables from the previous event instant
    \item $\vec{c}(t_{e})$ are boolean conditional expressions, given by when- and if-conditions
    \item $\vec{p}$ is a vector of system parameters and constants.
    \item $\vec{rel}(\vec{v}(t_{e}))$ is a boolean vector of relevant relation expressions in the model; $\vec{v}(t_{e}$ is a vector of all variables in the vectors above.
\end{itemize}

The equations are more thoroughly explained in \cite{openmodelica.org:lundvall:sims:2005}.

\subsection{DAE solution algorithm}

\begin{figure}[H]
    \centering
    \includegraphics{Figures/flowchart}
    \caption{Solution algorithm flowchart.\label{fig:dae-flowchart}}
\end{figure}

As stated, the system description in \cref{eq:dae-system} is only valid between events, and the simulation is therefore performed piecewise.
At event instants, points in time where the model is non-continuous, the hybrid DAE system must be reinitialized before simulation continues.
A flowchart describing the procedure is shown in \cite{openmodelica.org:lundvall:sims:2005}, and reproduced in \cref{fig:dae-flowchart}.
The following steps are performed when simulating the system:

\begin{enumerate}
    \item Before the continous part of the DAE, shown in \cref{eq:dae-continuous}, can be simulated, the system must determine the set of initial conditions for the problem.
	This generally requires the solution of a system of equations which determine the system constraints.

    \item After determining initial conditions, the system checks all event conditions, such as when- and if-statements, to see if any events need to be fired.

    \item After the event conditions are processed, events are fired if necessary.
	If any events were fired, the initial conditions must be recalculated and the simulation restarted with new initial conditions.
	Following this, event conditions are reevaluated as new conditions may have changed as a result of changes caused by the event.

    \item Once the system is stable, that is when no more events need to fire, the simulation proceeds.
	In this step, the vectors $\vec{q}$, $\vec{q_{pre}}$, and $\vec{c}$ are kept constant, so that \cref{eq:dae-continuous} is a set of continuous functions of continuous variables.

	Once any of the conditions in $\vec{c}$ that are relevant, determined by $\vec{rel}(\vec{v}(t_{e}))$, the continuous simulation is halted and event conditions are evaluated.
	The system repeats the process of firing events, and reevaluating conditions, until the new set of continuous equations can be simulated.
\end{enumerate}

The boolean conditions are divided into two groups, continuous or discrete.
Discrete conditions can only change value at discrete time instances $t_{e}$, and offer no problems.
These are simply evaluated at every discrete time step.
Continuous conditions are converted into a continuous function which crosses zero at the time the condition changes from true to false.
The DAE solution algorithm can efficiently monitor the function to detect when this happens \cite{openmodelica.org:lundvall:sims:2005}.

\end{document}
