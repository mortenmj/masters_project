%---------------------------------------------------------------------------------------
%   Modelica
%----------------------------------------------------------------------------------------

\providecommand{\rootfolder}{../..} % Relative path to main.tex
\documentclass[\rootfolder/main.tex]{subfiles}
\begin{document}
\section{Functional Mock-up Interface}

\subsection{Overview}

\begin{displayquote}[\cite{harman2006}][\dots]
    [The] \emph{Functional Mock-up Interface} (FMI) is a tool independent standard to support both model exchange and co-simulation of dynamic models using a combination of xml-files and compiled C-code
\end{displayquote}

Today, there are a variety of simulation tools available, which support a large variety of modelling languages.
Some tools are general purpose, such as Modelica, while others can be quite specialized.
In general, these tools do not interoperate.
In today's industry highly complex, interdisciplinary models are frequently required, which often requires the use of specialized modelling tools or languages.
Manufacturers have a need to connect models developed by their suppliers, but models have typically been locked into the software they are made in.  This has prompted the development of an open standard for model exchange.
FMI was developed for the exchange of models in the automotive industry, and aims to improve this issue.
Today, FMI is used by many companies both within and without the industry \ref{fmispecification}.
The standard is currently developed by the Modelica Association.

Using FMI, models can be developed and shared between simulation tools, allowing for greater reuse and early validation of designs \cite{Blochwitz2011}.
Additionally, simplified model exchange makes possible early validation of designs, as the designs from several suppliers can be tested together.

Modelica is one of the simulation packages that can export models to the FMI format, and all Modelica variable attributes can be exchanged.
The FMI models can be connected hierarchically, just like Modelica models, and they can optionally include their own solver, when using the FMI co-simulation standard.

The FMI standard defines an XML schema which is used to describe the model components, a C API for implementing the model.
This is used to define \emph{Functional Mock-up Unit}, or FMUs, which are typically exported from modelling tools which support the FMI standard.
An FMU consists of the following elements:

\begin{itemize}
    \item The model description file, an XML-file with all exposed variables in the model.
    \item The model implementation, A collection of C source files or the compiled binaries.
        This may be an implementation of the model equations, or an interface which communicates with an external tool.
    \item Additional data such as an icon bitmap, parameter tables, object libraries and so on.
\end{itemize}

Roughly, there are two ways FMI may be employed, as shown in \cref{fig:fmi}.
There are two modes of using FMUs.
Using \emph{model exchange}, the model is simply imported into a modelling tool which supports FMI and simulation is handled by the tool.
Using \emph{co-simulation}, each FMU handles its own simulation.

\begin{figure}[ht]
    \centering
    \subcaptionbox{Model exchange.\label{fig:fmi-exchange}}[0.4\columnwidth][l]
        {
            \includegraphics[width=0.37\columnwidth]{Figures/fmi-exchange}
        }
        \subcaptionbox{Co-simulation.\label{fig:fmi-cosim}}[0.4\columnwidth][r]
        {
            \includegraphics[width=0.37\columnwidth]{Figures/fmi-cosim}
        }
    \caption{The two interface standards for FMI.\label{fig:fmi}}
\end{figure}

\subsection{Model exchange}

\subsection{Co-simulation}

Often, complex models that combine multiple physical domains are difficult, or even impossible, to create with one software tool.
Using the FMI standard, this can be solved by modelling separate parts of the model in specialized software, and including the numerical solver with the model.
In the FMI standard, this is called co-simulation.

An illustrative example of the power of co-simulation is given in \cite{Schofield}, which implements an anti-lock braking system.
This is an example of a system that spans multiple physical domains.
As stated by \cite{Schofield}, Modelica is appropriate for models involving multiple physical domains.
However, while it is far more computationally intensive, in some cases the higher quality results that can be obtained by using finite element models justify the effort.
This is relevant in cases where physically-derived models are unavailable, or where high resolution is required.
In this case, while there are models which approximate tyre dynamics, such as the magic formula tyre model \cite{Pacejka2012}, these models do not capture as much detail as a finite element model.
Using co-simulation, it is possible to implement these parts as a finite element model, and other parts in e.g. Modelica, as shown by \cite{Schofield}.

Broadly speaking, the main components of an ABS system model is the tyre, the brake system, the road surface and the ABS controller.
Here, Abaqus is used to implement high-fidelity models of the tyre, road and brake caliper/disc assembly.
These components exhibit behaviors which cannot easily be captured in a model based tool such as those based on Modelica.

Many tyre manufacturers use detailed finite element models of their tyres to study the tyres response to different loading conditions;
As a result, tyre models and road surface models are available.
In \cite{Schofield}, a finite element model of the tyre, including the thread, plies and wire support structure is used in order to accurately predict the stresses and deformations of the tyre at different speeds.

The ABS controller, as well as the hydraulics of the braking system, are well suited for modelling in Modelica and are using the HyLib hydraulics library.
The ABS controller receives sensor data from the tyre, such as forward velocity of the vehicle, the angular velocity of the tyre and the effective rolling radius of the tyre as it deforms.
This information is transmitted from the finite element model, in Abaqus, to the control algorithm, in Dymola.
The ABS controller regulates an hydraulic solenoid and computes the brake caliper clamp force, which is transmitted back to Abaqus.
Abaqus then solves for the resulting dynamics in the brake caliper and tyre.

The paper compares this implementation to one created entirely with Modelica.
While the paper shows that it is possible to implement a simple model of the tyres and brakes in Modelica, it obtains more realistic results by using a high-fidelity finite element model.

\end{document}
