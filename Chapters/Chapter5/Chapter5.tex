% Chapter Template
\providecommand{\rootfolder}{../..} % Relative path to main.tex
\documentclass[\rootfolder/main.tex]{subfiles}
\begin{document}
\chapter{A domain-independent solution} % Main chapter title

\label{Chapter05} % Change X to a consecutive number; for referencing this chapter elsewhere, use \ref{ChapterX}

\section{General Requirements}

For any general purpose simulation suite to establish itself in the already crowded marketplace, it will need to be highly customisable.
In order to provide all the benefits of existing simulation suites, without simply offering a toolbox, the simulation suite needs a plugin-based architecture.
Features such as input- and output formats, the graphical interface, available solvers, language packs and model components should all be customisable by the user,
so that the software can be tailored to different needs.

A weakness in current solutions is that they are either too generic or too specific.
Matlab is an example of the former, where users need a lot of technical know-how in order to write simulations from scratch.
The Matlab language allows for any conceivable simulation problem to be run, but requires that the user knows the language,
and that the problem is described at a low abstraction level.
Other solutions are highly tailored to a particular field, or even sub-field, and only allow the user to simulation a constrained set of problems.
These software suites typically allow the user to quickly simulate a problem, as long as it is within the realm of problems supported by the software,
often with a graphical interface so that no programming experience is required of the user.

The benefit of the former is, of course, that any problem can be simulated given that the user has the required skill set.
In practice however, the result is frequently that a software solution is cobbled together by end users with little experience in the best practises of software architecture.
This leads to what software architects affectionately refer to as a big ball of mud.
Conversely, the latter approach allows users to quickly simulate problems, without much knowledge of the software, but leaves the user with little opportunity to customise the application if needed.

In order to better understand how these requirements might be met by a single piece of software, we will look at each of them in turn.

\section{Plugin API}

\section{Data Access}

\section{GUI}

\section{Input formats}

The two most powerful methods for describing systems, and also the most common, are the state space representation and the transfer function representation.
While classical control theory is based on transfer function analysis, it has several drawbacks.
Modern control theory largely relies on state space representation, which benefits from several powerful techniques in linear algebra.
While both methods can be used to represent linear time-invariant systems, the state space representation offers several attractive advantages:

While it is possible to extend the notion of transfer functions to time-variant and non-linear systems, it is rarely done.
Representing a nonlinear system requires a sequence of transfer functions \cite{Zhang1993}, and the stronger the nonlinearities are the more functions are required.
For this reason, the use of transfer functions is largely restricted to linear, time-invariant systems.

\begin{itemize}
	\item To treat multivariate systems in transfer function form requires a transfer function matrix. This can become unwieldy.
		Using the state space representation allows us to treat univariate and multivariate systems the same way.
	\item For any transfer function, there are many possible state space representations. Therefore, converting to the transfer function form involves a loss of information.
		The state space representation maintains this information, allowing greater insight into the inner workings of the system.
	\item The state space representation allows for non-zero initial conditions, unlike a transfer function representation.
	\item The state space representation is defined for linear and non-linear systems, unlike a transfer function representation which is only defined for linear systems.
	\item The state space representation is defined for time-variant and time-invariant systems, unlike a transfer function representation which is only defined for time invariant systems.
	\item Given the state space representation, it is simple to determine if the system is observable and controllable.
\end{itemize}

To see how a state space representation may be represented in software, it is useful to review how it is defined.
A system with states $x_{1}$ to $x_{p}$ and outputs $y_{1}$ to $y_{r}$ are related by the following equations:

\loadeq{\rootfolder/Equations.tex}{001}

We can rearrange this to represent the variables as vectors, and the coefficient as matrices:
\loadeq{\rootfolder/Equations.tex}{002}

Finally, in compact form, this may be written as:
\loadeq{\rootfolder/Equations.tex}{003}

As we can see, this system can be uniquely identified in the software by the matrices $(A, B, C, D)$, and it follows that this would be all we need to pass to a solver in order to simulate the system.
However, in order to separate the model from the simulation setup, and to promote sharing of models, a richer input format would be desirable.
In order to promote sharing of models, it is useful to attach metadata to the model, such as units.
It would also be desirable to store the model in a format where variables and coefficients can have descriptive names.
While the format described above, where the model is defined by its coefficient matrices, is sufficient to define the model mathematically, it is insufficient in these regards.
In order to fulfill all of these requirements, storing the model as MathML would be more feasible.
An input method like the one employed by OpenCOR, which we reviewed earlier, would be one possible solution, as shown in %\cref{fig:opencor-input}.

\section{Output formats}

\subsection{Plotting Engine}

\section{Solvers}

\begin{figure}[h]
  \centering
%  \includegraphics{solverinterface-uml}
  \caption{Solver interface.\label{fig:solver-interface}}
\end{figure}

As it is desirable that solvers also be implemented in plugins, it is necessary to specify an API.

\subsection{Criteria}

The API should allow for as wide a range of implementations as possible, and roughly in any conceivable language.
The reasons for this need for flexibility are several.

While implementing solvers in a procedural or functional language might yield impressive performance, the result is often code that is difficult to understand.
Implementing in an object oriented language allows for abstraction of the numerical algorithm, and permits code that is divided into well-defined, self-contained modules \cite{kees1999}.
However, programmers may also deem that the computational overhead of an object oriented solution outweighs the benefits, and would therefore prefer to implement the solver in some other paradigm.
Our interface must be sufficiently flexible to allow for both approaches, so that implementers can make this choice themselves.
Furthermore, much research has gone into the development of efficient solvers in the past century, and it would be very useful to simply integrate these as plugins in our software.

The API should allow for solvers of ordinary differential equations, partial differential equations and non-linear differential equations.
This will not be an API for implementing solvers, but rather an API for how such a solver should interface with the rest of our simulation framework.

In order to create a pleasant user experience, it would be beneficial if the solver could report data to the application as the simulation progresses.
This way, the user can see the graph being drawn in real time, and can stop and reconfigure the simulation if that is desired.
This is also in line with the requirements of responsive design; The user sees that the application is working, and therefore has a better user experience.
It is important that this continous feedback is an option, and not a hard requirement, so that the coupling between the solver and the application doesn't impose limitations on solver implementers.

In some cases it may be desirable to run the solver on some other machine, or indeed even a cluster of machines, and our API should be flexible enough to allow for this.
Therefore, we need an API where the solver can report data to the application, even when running remotely.
However, it would not be desirable to impose this as a requirement, as that may limit certain implementations.
Whether or not the solver can provide data to the GUI in real time should be reported to the application, so that the lack of information isn't interpreted as an error by the user.

\subsection{Considerations}

To determine the required parameters for our solver API, we will have to look more closely at the types of differential equations we intend to support.
There are two ways we can represent systems of differential equations in our application.
We can require the user to supply the system in a matrix representation, or we can require a function $f(x)$, that returns $dx/dt$.
In the case where $x$ is multivariate, $f(x)$ should return an array of results.
Systems of linear differential equations can be specified in matrix form in the following manner \cite{kreyzig}:

\loadeq{\rootfolder/Equations.tex}{001}

As we can see, it would suffice to have an array of size $n$ for the state variables,
a two-dimensional array of size $n \times n$ for the constants and another array of size $n$ for the constant terms.
Linear partial differential equations can be reduced to this form and this should be done before passing the equations to the solver.

Support for differential algebraic equations complicate the matter somewhat, but not much.
In addition to the specification outlined above, we would need to specify the algebraic constraints in a similar fashion.
However, nonlinear systems obviously can not be written in such a form \cite{khalil}.
Generally, solvers of nonlinear algebraic equations take as input a problem-defining function.

In order to provide the same API for both classes of problems, it might be more useful to require that the user supplies such a function.
In addition, specialized solvers may require that other functions are supplied \cite{kinsol}\cite{cvode}\cite{ida}.
Where solver implementations require that the user supplies functions such as these, they should either be implemented in our wrapper,
or we should provide an interface for the user to supply their own implementation.
In the latter case, it would be useful to supply a default implementation, so that the solver can be used out of the box.

For linear solvers, whether they be for ordinary or partial differential equations, we need an initial time value, as well as an end value.
Other information the solver needs, such as time step for fixed-step solvers, tolerance and so on, can be set in a key-value manner in Properties.

\subsection{Proposal}

%\begin{figure}[h]
%  \centering
%  \includegraphics{basesolver-uml}
%  \caption{Solver base class.\label{fig:solver-baseclass}}
%\end{figure}

\subsubsection{General}

The interface, shown in \cref{fig:solver-interface}, allows the solver implementation to provide the framework with a unique ID, a human-readable name, a
type (ODE, PDE, etc.\@), and any relevant properties that must be configured by the user.
One such property might for example be the desired number of steps, in the case of e.g. Euler's method.
The Solver class needs to be sufficiently flexible that it can be inherited by classes for implementing all the solver types mentioned above.

\subsubsection{Linear solvers}

%\begin{figure}[h]
%  \centering
%  \includegraphics{solverinheritance-uml}
%  \caption{Linear differential equation solver class.\label{fig:solver-linear}}
%\end{figure}


\subsubsection{Non-linear solvers}

\section{Internationalization}

\section{Model sharing}

\end{document}
