%----------------------------------------------------------------------------------------
%   MATLAB
%----------------------------------------------------------------------------------------

\providecommand{\rootfolder}{../..} % Relative path to main.tex
\documentclass[\rootfolder/main.tex]{subfiles}
\begin{document}
\section{Simulation}

When simulating a model in Matlab the procedure is somewhat different depending on whether the model is defined in Matlab code, or in Simulink or Simscape.

\subsection{Simulink}

\subsubsection{Simulink model compilation}

When simulating a simulink model, the compiler first determines the values of any variables used in the model.
In our example, several values are set in a Matlab script and the compiler must populate the model with the numerical values before proceeding.
In the case of symbolic expressions, these must be resolved to determine the resulting numerical value that is used in the simulation.
The data type, numeric type and dimensions of signals are also checked, to ensure that every block in the model is compatible with the signals that are applied to it.

\begin{figure}[ht]
    \centering
    \tiny
    \includesvg[width=0.8\columnwidth]{Figures/InertialSimulinkOrder}
    \caption{Execution order for the plant subsystem.\label{fig:inertial-simulink-order}}
\end{figure}

After this, the algorithm determines the sorted execution order for the model, so that blocks are executed in an order which reflects their data dependencies.
This turns the graphical model into a sequentially executed program that can be simulated by a computer.
\Cref{fig:inertial-simulink-order} shows the execution order for the model we have been working with.
The execution order is determined by the algorithm, but the designer can exert some influence on it by assigning higher priority a block.
It is also possible to designate a subsystem as atomic, so that the whole subsystem is executed as a single unit.
Beyond this virtual blocks, such as subsystems, are flattened and do not influence the execution order.

Finally, the sample times are determined for blocks that have inherited sample times.

\subsubsection{Model linking}

After the model is compiled, the Simulink engine allocates working memory for the model execution, as well as memory for run-time data that is to be stored.
The method execution list, which lists the most efficient execution order of the model blocks, is generated from the sorted order lists found previously.

\subsubsection{Loop phase}

After model linking, the algorithm proceeds to the simulation loop phase.
The loop phase is separated into two subphases, the initialization phase and the iteration phase.

First, during initialization, the system determines the initial states for the system and the output values that need to be computed.
Then, during the loop iteration phase, the following takes place:

\begin{enumerate}
    \item Computation of outputs
    \item Computation of the model states
        This step is performed by invoking a solver.
        Which solver depends on whether the model has no states, only continuous states, only discrete states or both types of states.
        The user can specify which continuous and discrete solver to use, or the system can be asked to determine the optimal solver automatically.
    \item Discontinuity checks
    \item Computation of the time until the next time step
\end{enumerate}

These steps are repeated until the simulation end-time.

\subsection{Simscape}

Simulation of Simscape models is somewhat more involved, as the model is acausal.

\subsubsection{Model validation}

Some model validation is performed above, but for acausal models the procedure is more involved.
When simulating a Simscape model, the system ensures that all blocks are connected.
It is not allowed to leave conserving ports, such as those representing hydraulic flow or energy flow, unconnected.
Models containing fluid or gas flow networks require that no more than one block which specifies the properties of the fluid or gas is connected to each network.

\subsubsection{Network construction}

After this, the system creates the physical network.
This is based on two types of properties.

\begin{itemize}
    \item Through-properties (e.g. current) are those which are measured in series with an element
    \item Across-properties (e.g. voltage) are those which are measured in parallel with an element
\end{itemize}

The system follows the rules that for every through-variable, the sum of the values going into a node equal those going out.
Conversely, for every across-variable, two directly connected elements have the same value.
The system creates the physical network following these two principles.

\subsubsection{Equation construction}

The system equations are then developed from this network, and the equations are simulated in a similar fashion to the procedure explained for normal Simulink models.
Overall, the process is similar to that described in \ref{Chapter02}.

\end{document}
